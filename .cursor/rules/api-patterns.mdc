---
description: 
globs: src/lib/api/**/*.ts,src/app/api/**/*.ts,src/lib/apiClient.ts,src/lib/*Server.ts,src/hooks/use*Swap*.ts,src/hooks/use*Borrow*.ts,src/hooks/use*Quote*.ts,src/hooks/use*Liquidium*.ts,src/hooks/useSwap*.ts,src/hooks/useBorrow*.ts,src/hooks/useLiquidium*.ts
alwaysApply: false
---
# API Patterns & Integration Guide

## API Client Architecture

The API client is **distributed across multiple files** in `src/lib/api/`, not centralized in `apiClient.ts`.

### File Structure
```text
src/lib/
├── apiClient.ts          # Barrel export (re-exports from api/)
├── api/
│   ├── index.ts          # Main API client methods
│   ├── ordiscan.ts       # Ordiscan SDK integration
│   ├── satsTerminal.ts   # SatsTerminal SDK integration  
│   ├── liquidium.ts      # Liquidium API integration
│   ├── coingecko.ts      # CoinGecko API integration
│   └── utils.ts          # API utility functions
├── liquidiumServer.ts    # Server-side Liquidium utilities
├── popularRunesCache.ts  # Caching layer for popular runes
└── runeMarketData.ts     # Market data aggregation
```

## API Route Patterns

### Standard Next.js API Route Structure
```typescript
// src/app/api/example/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createErrorResponse, createSuccessResponse } from '@/lib/api/utils';

export async function GET(request: NextRequest) {
  try {
    // Extract and validate parameters
    const { searchParams } = new URL(request.url);
    const param = searchParams.get('param');
    
    if (!param) {
      return createErrorResponse(
        'Parameter required', 
        'Missing required parameter: param',
        400
      );
    }

    // Call external service
    const data = await externalAPICall(param);
    
    return createSuccessResponse(data);
  } catch (error) {
    return createErrorResponse(
      'Service unavailable',
      `Failed to fetch data: ${error instanceof Error ? error.message : 'Unknown error'}`,
      500
    );
  }
}
```

### Error Response Standardization
Always use helper functions from `@/lib/api/utils`:

```typescript
// ✅ Correct - Standardized error responses
import { createErrorResponse, createSuccessResponse } from '@/lib/api/utils';

// Success response
return createSuccessResponse(data);

// Error response with details
return createErrorResponse(
  'User-friendly message',
  'Technical details for debugging', 
  statusCode
);
```

## External Service Integration Patterns

### Ordiscan Integration
```typescript
// ✅ Use the ordiscan SDK directly
import { ordiscan } from 'ordiscan';

export async function getRuneInfo(runeId: string) {
  try {
    const runeData = await ordiscan.runes.getRuneInfo(runeId);
    return runeData;
  } catch (error) {
    throw new Error(`Failed to fetch rune info: ${error}`);
  }
}
```

### SatsTerminal Integration
```typescript
// ✅ Use satsterminal-sdk
import { SatsTerminalSDK } from 'satsterminal-sdk';

const sdk = new SatsTerminalSDK({
  apiKey: process.env.SATS_TERMINAL_API_KEY!,
});

export async function createSwapQuote(params: QuoteParams) {
  return await sdk.swap.getQuote(params);
}
```

### Liquidium Integration (Server-side)
```typescript
// ✅ Server-side only - never expose API key to client
const response = await fetch(`${LIQUIDIUM_API_URL}/endpoint`, {
  headers: {
    'Authorization': `Bearer ${process.env.LIQUIDIUM_API_KEY}`,
    'Content-Type': 'application/json',
  },
  body: JSON.stringify(payload),
});
```

## Caching Strategies

### Supabase Caching Pattern
```typescript
// ✅ Cache frequently accessed data in Supabase
export async function getCachedRuneData(runeId: string) {
  // Check cache first
  const { data: cached } = await supabase
    .from('rune_cache')
    .select('*')
    .eq('rune_id', runeId)
    .single();

  if (cached && isCacheValid(cached.updated_at)) {
    return cached.data;
  }

  // Fetch fresh data
  const freshData = await ordiscan.runes.getRuneInfo(runeId);
  
  // Update cache
  await supabase
    .from('rune_cache')
    .upsert({
      rune_id: runeId,
      data: freshData,
      updated_at: new Date().toISOString(),
    });

  return freshData;
}
```

### React Query Integration
```typescript
// ✅ Client-side data fetching with React Query
export function useRuneData(runeId: string) {
  return useQuery({
    queryKey: ['rune-data', runeId],
    queryFn: async () => {
      const response = await fetch(`/api/ordiscan/rune-info?id=${runeId}`);
      if (!response.ok) throw new Error('Failed to fetch rune data');
      return response.json();
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
    retry: 3,
  });
}
```

## Environment Variable Validation

```typescript
// ✅ Always validate required environment variables
function validateApiKeys() {
  const required = [
    'SATS_TERMINAL_API_KEY',
    'ORDISCAN_API_KEY', 
    'LIQUIDIUM_API_KEY'
  ];
  
  for (const key of required) {
    if (!process.env[key]) {
      throw new Error(`${key} environment variable is required`);
    }
  }
}
```

## Testing API Routes

```typescript
// ✅ API route testing pattern
import { createMocks } from 'node-mocks-http';
import handler from './route';

describe('/api/example', () => {
  test('handles valid request', async () => {
    const { req, res } = createMocks({
      method: 'GET',
      query: { param: 'value' },
    });

    await handler(req, res);

    expect(res._getStatusCode()).toBe(200);
    const data = JSON.parse(res._getData());
    expect(data.success).toBe(true);
  });
});
```

## Common Anti-patterns

### ❌ Don't Do This
```typescript
// Don't expose sensitive keys to client
const apiKey = process.env.NEXT_PUBLIC_LIQUIDIUM_API_KEY; // Wrong!

// Don't use direct array access
const firstResult = results[0]; // Could throw

// Don't skip error handling
const data = await externalAPI.call(); // Could fail silently
```

### ✅ Do This Instead
```typescript
// Server-side API key usage
const apiKey = process.env.LIQUIDIUM_API_KEY; // Correct

// Safe array access
const firstResult = safeArrayFirst(results); // Type-safe

// Proper error handling
try {
  const data = await externalAPI.call();
  return createSuccessResponse(data);
} catch (error) {
  return createErrorResponse('Failed to fetch', error.message, 500);
}
```
